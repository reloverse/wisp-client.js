/*! For license information please see wisp-client.bundle.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.WispClient=t():e.WispClient=t()}(this,()=>(()=>{"use strict";var e={d:(t,s)=>{for(var n in s)e.o(s,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:s[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>_});const s=Object.freeze({CONNECT:1,DATA:2,CONTINUE:3,CLOSE:4}),n=Object.freeze({UNKNOWN:1,VOLUNTARY:2,NETWORK_ERR:3,INVALID_INFO:65,HOST_UNREACHABLE:66,CONNECT_TIMEOUT:67,CONNECTION_REFUSED:68,TCP_TIMEOUT:71,BLOCKED_DEST:72,THROTTLED:73,CLIENT_FATAL:129}),i=Object.freeze(Object.fromEntries(Object.entries(s).map(([e,t])=>[t,e])));function r(e){switch(e.length){case 1:return e[0];case 2:return new Uint16Array(e.buffer)[0];case 4:return new Uint32Array(e.buffer)[0];default:throw new Error("Invalid array length")}}function o(e,t){const s=new ArrayBuffer(t),n=new DataView(s);if(1===t)n.setUint8(0,e,!0);else if(2===t)n.setUint16(0,e,!0);else{if(4!==t)throw new Error("Invalid array length");n.setUint32(0,e,!0)}return new Uint8Array(s)}const c=(...e)=>new Uint8Array(e.flatMap(e=>[...e]));function a(e,t,s){return c(o(e,1),o(t,4),s)}class h extends EventTarget{hostname;port;#e;#t;#s;#n;#i;#r;#o=[];constructor(e,t,s,n,i,r,o){super(),this.hostname=e,this.port=t,this.#e=s,this.#n=n,this.#s=i,this.#t=r,this.#i=o,this.#r=!0}get readyState(){return this.#r?1:3}send(e){if(!this.#r)throw new Error("Stream is closed");const t="string"==typeof e?(new TextEncoder).encode(e):e;if(null===this.#n||this.#n>0||2===this.#i){const e=a(s.DATA,this.#s,t);this.#e.send(e),null!==this.#n&&2!==this.#i&&this.#n--}else this.#o.push(t)}_continue_received(e){for(this.#n=e;this.#n>0&&this.#o.length>0;)this.send(this.#o.shift())}close(e=1){if(!this.#r)return;const t=o(e,1);this.#e.send(a(s.CLOSE,this.#s,t)),this.#r=!1;const n=new CloseEvent("close",{code:e});this.dispatchEvent(n),delete this.#t.active_streams[this.#s]}}class f extends EventTarget{wisp_url;max_buffer_size=null;active_streams={};#e;#c=!1;#a=!1;#h=1;constructor(e){if(super(),!e.endsWith("/"))throw new Error("Wisp endpoints must end with '/'");this.wisp_url=e,this.#f()}#f(){this.#e=new WebSocket(this.wisp_url),this.#e.binaryType="arraybuffer",this.#a=!0,this.#e.addEventListener("error",()=>{this.#_(),this.dispatchEvent(new Event("error"))}),this.#e.addEventListener("close",()=>{this.#_(),this.dispatchEvent(new CloseEvent("close"))}),this.#e.addEventListener("message",e=>this.#d(e))}create_stream(e,t,n="tcp"){const i="udp"===n?2:1,r=this.#h++,f=new h(e,t,this.#e,this.max_buffer_size,r,this,i),_=c(o(i,1),o(t,2),(new TextEncoder).encode(e));return this.active_streams[r]=f,this.#e.send(a(s.CONNECT,r,_)),f}#d(e){const t=new Uint8Array(e.data);if(t.length<5)return console.warn("packet too short");const n=t[0],o=r(t.slice(1,5)),c=t.slice(5);if(n===s.CONTINUE&&0===o)return this.max_buffer_size=r(c),this.#c=!0,this.#a=!1,void this.dispatchEvent(new Event("open"));const a=this.active_streams[o];if(a||0===o)switch(n){case s.DATA:a.dispatchEvent(new MessageEvent("message",{data:c}));break;case s.CONTINUE:a._continue_received(r(c));break;case s.CLOSE:a.close(c[0]);break;default:console.warn(`Unknown packet type ${n}`)}else console.warn(`Received ${i[n]} for not existent stream`)}#_(){this.#c=!1,this.#a=!1;for(const e of Object.values(this.active_streams))e.close(s.NETWORK_ERR)}}const _={WispConnection:f,WispStream:h,packet_names:i,packet_types:s,close_codes:n};return t.default})());